
class Solution {
/********BFS Aprroach**********/
//     private:
//     bool detect(int src,vector<vector<int>>&adj ,int vis[]){
//         vis[src]=1;
//         queue<pair<int,int>>q;
//         q.push({src,-1});
//         while(!q.empty()){
//             int node=q.front().first;
//             int parent=q.front().second;
//             q.pop();
//             for(auto adjacentNode:adj[node]){
//                 if(!vis[adjacentNode]){
//                     vis[adjacentNode]=1;
//                     q.push({adjacentNode,node});
//                 }else if(parent!=adjacentNode){
//                     return true;
//                 }
//             }
//         }
//     return false;
//     }
//   public:
//     // Function to detect cycle in an undirected graph.
//     bool isCycle(vector<vector<int>>& adj) {
//         int n=adj.size();
//         int vis[n]={0};
//         for(int i=0;i<n;i++){
//             if(!vis[i]){
//                 if(detect(i,adj,vis)){
//                     return true;
//                 }
//             }
//         }
//     return false;
//     }
// };
// // T.C-O(N+2E);
// S.C-O(N);
/**************DFS Approach************/
 private:
bool dfs(int node,int parent,vector<int>&vis,vector<vector<int>>& adj){
    vis[node]=1;
    for(auto adjacent:adj[node]){
        if(!vis[adjacent]){
            if(dfs(adjacent,node,vis,adj)==true){
                return true;
            }
        }else if(adjacent!=parent){
                return true;
            }
    }
    return false;
}
public:
    // Function to detect cycle in an undirected graph.
    bool isCycle(vector<vector<int>>& adj) {
        int n=adj.size();
        vector<int>vis(n,0);
        for(int i=0;i<n;i++){
            if(vis[i]==0){
                if(dfs(i,-1,vis,adj)){
                    return true;
                }
            }
        }
        return false;
    }
};
/// T.C-O(N+2E);
// S.C-O(N);
